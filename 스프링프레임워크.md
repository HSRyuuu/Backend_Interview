## 스프링 프레임워크 란?
스프링 프레임워크(Spring Framework)는 자바 기반의 오픈소스 애플리케이션 프레임워크입니다.

스프링 프레임워크는 `제어 역전(IoC)`와 `의존성 주입(DI)`을 통해 객체 생성과 의존성 관리를 담당하게 되어, 
개발자는 객체간의 의존성을 직접 관리하는 대신, 스프링 컨테이너에게 제어권을 넘김으로써 유연하고 확장성 있는 
애플리케이션을 구성할 수 있습니다.  
또한, `관점 지향 프로그래밍(AOP)`을 지원하여 어플리케이션의 부가 기능을 모듈화 할 수 있습니다.
로깅, 트랜잭션과 같은 관심사를 분리하여 핵심 비즈니스 로직과 분리된 모듈로 관리할 수 있습니다.

## 의존성 주입 (DI : Dependency Injection) 이란?
DI는 객체간의 의존성을 줄이고 유지보수성을 높이기 위해 사용됩니다. 
객체간의 의존성을 스프링 컨테이너가 주입해주는 형식으로 DI를 지원합니다.  
`생성자 주입`, `Setter 주입`,` Field 주입` 세가지 방법이 있는데, 이 중 `생성자 주입`을 권장합니다.
객체를 정의하고 관리하는 역할을 스프링 컨테이너에게 위임하여 객체간의 결합도를 낮추고 유연한 구조를 유지할 수 있게되어, 
개발자는 객체 생성에 대한 부분을 신경쓰지 않고 비즈니스 로직에만 집중할 수 있게 되어, 코드의 `가독성`과 `유지보수성`을 높일 수 있습니다.

## 제어의 역전(IoC : Inversino of Control)
IoC는 객체의 생성과 관리를 스프링 프레임워크가 대신하도록 위임하는 것을 말합니다. 스프링 컨테이너에 `객체(Bean)`을 미리 등록하고, 필요한 곳에서 컨테이너에서 빈을 가져와 사용할 수 있게 됩니다. 
이 때, Bean을 가져올 때 `의존성 주입(DI)` 방식을 사용하여 객체 간의 의존성을 자동으로 주입받을 수 있게 됩니다.  
IoC를 사용하면 객체 간의 의존성 관리가 용이해지고, 유지보수성과 확장성이 높아지고, 객체의 라이프사이클 관리나 `AOP` 
등의 고급 기능을 사용할 수 있게 됩니다.

## Spring Bean
### Bean 이란?
Bean은 `스프링 컨테이너에 의해 관리되는 객체`를 말합니다. 빈은 스프링 컨테이너에 등록되어 객체의 생성, 의존성 주입, 라이프사이클 관리 등을 
스프링이 대신 처리할 수 있도록 합니다. `@Bean` 어노테이션을 사용해 `@Configuration`으로 직접 등록하여 사용하거나,
클래스에 `@Component` 어노테이션을 사용하여 등록할 수 있습니다. 

### Bean의 생성 과정
`객체 생성` -> `의존 설정` -> `초기화` -> `사용` -> `소멸` 과정의 생명주기를 가지고 있습니다.  
스프링 컨테이너가 생명 주기를 관리하며, 빈은 `@PostConstruct`으로 초기화하고, `@PreDestroy`를 사용하여 소멸합니다.

### Bean Scope란?
빈 스코프는 빈이 존재할 수 있는 범위를 뜻하며, `싱글톤`, `프로토타입`, `Request`, `Session` 등이 있습니다.  
`싱글톤(Singleton)`이 기본 스코프로 설정되며 이는 스프링 컨테이너 내에서 해당 빈이 한개의 인스턴스만 생성하여 
동일한 인스턴스를 공유하여 사용할 수 있게 됨을 뜻합니다.  

## AOP(Aspect-Oriented Programmming)란?
AOP는 프로그래밍의 한가지 패러다임으로, `애플리케이션의 핵심 로직과 부가 기능(관점)을 분리`하여 모듈화하는 개념입니다. 
주로 코드의 `횡단 관심사(Cross-cutting Concerns)`를 분리하여 코드 중복을 줄이고 유지보수성을 향상시킵니다.
- `관점(Aspect)` : 횡단 관심사를 구현한 모듈입니다. `로깅`, `트랜잭션 관리`, `보안` 등을 관점으로 볼 수 있습니다.  
  이러한 관점은 주요 비즈니스 로직과 분리되어 개별적으로 작성되며, 여러 객체나 메서드에 적용될 수 있습니다.
- `Join Point` : Join Point는 관점이 적용될 수 있는 프로그램의 실행 지점입니다.  
   메서드 호출, 예외 발생, 필드 값 변경 등이 JoinPoint에 해당됩니다.
- `Advice` : Advice는 관점의 동작(로직) 자체를 정의한 것입니다. JoinPoint에 적용될 때 실행되는 코드입니다.
- `Pointcut` : Pointcut은 어떤 조인 포인트를 선택할 지 결정하는 기준입니다.  
   포인트컷은 특정 클래스, 메서드, 패키지 등과 같은 선별 기준을 적용할 수 있습니다.
- `Advisor` : Advisor는 Pointcut과 Advice의 결합을 나타냅니다. 어떤 JoinPoint에 어떤 Advice를 적용할 지 결정합니다.

스프링 프레임워크는 이러한 AOP를 지원하고, AOP 기능을 활용하여 애플리케이션에 관심사를 분리하여 적용할 수 있습니다.  
AOP 역시 코드의 재사용성과 유지보수성을 향상시킵니다.

## POJO란?
POJO는 `Palin Old Java Object`의 약자로 순수한 자바 객체를 뜻합니다.  
POJO는 특정 프레임워크나 라이브러리에 종속되지 않은 일반적인 자바 클래스를 의미합니다. 일반적인 자바 클래스로 특정 제약이나 
규칙을 다르지 않고, Java에서 제공하는 API외에 종속되지 않습니다.  
스프링에서 POJO는 특정 환경에 종속되지 않아 코드가 간결하고 테스트 자동화에 유리합니다.

## Spring MVC 패턴
MVC 패턴은 `Model` `View` `Controller`의 약자로, 애플리케이션을 구성하는 컴포넌트의 역할을 세가지로 구분하여 설계하는 패턴입니다.  
`Model`은 비즈니스 로직과 데이터를 담당합니다. 데이터를 저장하고 처리하는 역할을 하며, 주로 DB와 연동됩니다.  
`View`는 모델에서 처리된 데이터를 사용자에게 보여주는 역할을 합니다. 주로 HTML, CSS, JS로 이루어진 프론트 영역을 말합니다.  
`Controller`는 클라이언트의 요청을 처리하고, 그 결과를 View에 전달하는 역할을 합니다. 요청을 받고 해당 요청에 대한 처리를 담당하는 컴포넌트로,
비즈니스 로직(Model)과 뷰(View) 사이의 중간 다리 역할을 합니다.  

### MVC 패턴 과정
1. 사용자 요청을 DispatcherServlet이 받아들입니다.
2. DispatcherServlet은 Handler Mapping을 통해 해당 요청을 처리할 컨트롤러(Controller)를 찾습니다.
3. Controller는 비즈니스 로직을 실행하여 데이터(Model)를 생성하고, 뷰(View)에 전달합니다.
4. View는 Model에서 받은 데이터를 사용하여 사용자 인터페이스를 생성합니다.
5. Dispatcher Servlet은 생성된 View를 사용자에게 반환합니다.

MVC 패턴을 사용하면, 애플리케이션의 각 역할을 분리하여 유지보수성이 높아지고, 코드의 재사용성도 증가합니다.

### DispatcherServlet 상세 동작 구조
1. 클라이언트 요청 : 클라이언트 요청(HttpServletRequest) -> 서블릿 컨테이너는 `DispatcherServlet`으로 전달
2. Handler 조회 : `Handler Mapping`을 통해 URI에 요청된 핸들러(Controller)를 탐색한다.
3. Handler Adapter 조회 : 조회한 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
4. Handler Adapter 실행 : 핸들러 어댑터를 통해 핸들러(Controller)을 호출한다.
5. Handler 실행 : 핸들러(Controller)를 실행하여 요청을 처리하고, 응답을 다시 핸들러 어댑터로 반환한다.
6. 핸들러 어댑터는 이 응답을 `ModelAndView`로 가공하여 반환한다.  
7. `View Resolver`를 찾고 실행한다.
8. ViewResolver는 `View`의 논리 이름을 물리 이름으로 바꾸고, 랜더링 역할을 담당하는 View 객체를 반환한다.
9. View를 랜더링 하여 클라이언트에 반환한다.

#### @RestController 사용 시
- 7~9번 과정을 거치지 않고 데이터를 `MessageConverter`를 거쳐 `JSON` 형식으로 변환한다. 
- JSON을 ResponseBody로 응답한다.


